// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("POSTGRES_PRISMA_URL")
  directUrl = env("POSTGRES_URL_NON_POOLING") // uses a direct connection
}

model User {
  //wallet that will be used for transactions
  wallet                      String    @unique @db.VarChar(50)
  //Wallet that will be used to fetch social info of the user
  socialWallet                String?   @unique @db.VarChar(50)
  privyUserId                 String?   @unique
  //Each social platform can have it's own avatar and name. One will be chosen as the main one
  displayName                 String?   @db.VarChar(255)
  avatarUrl                   String?   @db.VarChar(500)
  isActive                    Boolean   @default(false)
  isAdmin                     Boolean   @default(false)
  hasFinishedOnboarding       Boolean   @default(false)
  lastRecommendationsSyncedAt DateTime?
  bio                         String?   @db.VarChar(500)

  questions            Question[]                @relation("questioner")
  replies              Question[]                @relation("replier")
  inviteCodes          InviteCode[]
  comments             Comment[]
  invitedBy            InviteCode?               @relation("invitation", fields: [invitedById], references: [id])
  invitedById          Int?
  points               Point[]
  reactions            Reaction[]
  socialProfiles       SocialProfile[]
  tags                 Tag[]
  notifications        Notification[]            @relation("targetUser")
  sourceNotifications  Notification[]
  notificationSettings UserNotificationSetting[]
  quests               UserQuest[]

  id               Int                @id @default(autoincrement())
  createdAt        DateTime           @default(now())
  updatedAt        DateTime           @updatedAt
  SigningChallenge SigningChallenge[]
  recommendedTo    RecommendedUser[]  @relation("recommendationTarget")
  recommendedUsers RecommendedUser[]  @relation("recommendationSource")
  keysOfSelf       KeyRelationship[]  @relation("owner")
  keysOwned        KeyRelationship[]  @relation("holder")
}

enum SocialProfileType {
  FARCASTER
  LENS
  TALENT_PROTOCOL
  ENS
}

model SocialProfile {
  type           SocialProfileType
  profileName    String            @db.VarChar(255)
  profileImage   String?           @db.VarChar(500)
  bio            String?           @db.VarChar(500)
  followerCount  Int?
  followingCount Int?
  user           User              @relation(fields: [userId], references: [id])
  userId         Int
  //Just in case we need to store data specific to each social platform
  socialData     Json?

  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  //Only 1 profile type per user
  @@unique([userId, type])
}

model Question {
  questionContent String     @db.VarChar(500)
  questioner      User       @relation("questioner", fields: [questionerId], references: [id])
  questionerId    Int
  reply           String?    @db.VarChar
  replier         User       @relation("replier", fields: [replierId], references: [id])
  replierId       Int
  repliedOn       DateTime?
  comments        Comment[]
  reactions       Reaction[]
  replyReactions  Reaction[] @relation("ReplyReaction")

  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Comment {
  content    String     @db.VarChar
  question   Question   @relation(fields: [questionId], references: [id], onDelete: Cascade)
  questionId Int
  author     User       @relation(fields: [authorId], references: [id])
  authorId   Int
  reactions  Reaction[]

  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

enum ReactionType {
  UPVOTE
  DOWNVOTE
  LIKE
}

model Reaction {
  reactionType ReactionType
  user         User         @relation(fields: [userId], references: [id])
  userId       Int
  question     Question?    @relation(fields: [questionId], references: [id], onDelete: Cascade)
  questionId   Int?
  reply        Question?    @relation(fields: [replyId], references: [id], name: "ReplyReaction", onDelete: Cascade)
  replyId      Int?
  comment      Comment?     @relation(fields: [commentId], references: [id], onDelete: Cascade)
  commentId    Int?

  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([userId, questionId])
  @@unique([userId, replyId])
  @@unique([userId, commentId])
}

model InviteCode {
  code        String  @unique @db.VarChar(50)
  user        User    @relation(fields: [userId], references: [id])
  userId      Int
  invitations User[]  @relation("invitation")
  maxUses     Int
  used        Int
  isActive    Boolean @default(false)

  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Point {
  description String  @db.VarChar(500)
  user        User    @relation(fields: [userId], references: [id])
  userId      Int
  points      Int
  hidden      Boolean
  claimed     Boolean @default(false)

  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model RecommendedUser {
  id    Int  @id @default(autoincrement())
  for   User @relation(fields: [forId], references: [id], name: "recommendationSource")
  forId Int

  user           User?   @relation(fields: [userId], references: [id], name: "recommendationTarget")
  userId         Int?
  wallet         String
  avatarUrl      String?
  ens            String?
  farcaster      String?
  lens           String?
  talentProtocol String?

  recommendationScore Int

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([forId, wallet])
}

model SigningChallenge {
  message   String
  user      User   @relation(fields: [userId], references: [id])
  userId    Int    @unique
  publicKey String

  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Tag {
  name  String @unique @db.VarChar(255)
  users User[]

  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

enum NotificationType {
  ASKED_QUESTION
  REPLIED_YOUR_QUESTION
  REPLIED_OTHER_QUESTION
  QUESTION_UPVOTED
  QUESTION_DOWNVOTED
  REPLY_REACTION
  KEYBUY
  KEYSELL
  USER_INVITED
  FRIEND_JOINED
  POINTS_DROP
  NEW_INVITE_CODE
  SYSTEM
}

model Notification {
  targetUser   User    @relation(fields: [targetUserId], references: [id], name: "targetUser")
  targetUserId Int
  sourceUser   User?   @relation(fields: [sourceUserId], references: [id])
  sourceUserId Int?
  description  String?

  isRead Boolean          @default(false)
  readAt DateTime?
  type   NotificationType

  referenceId Int?

  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model UserNotificationSetting {
  user             User             @relation(fields: [userId], references: [id])
  userId           Int
  notificationType NotificationType
  isDisabled       Boolean          @default(false)

  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([userId, notificationType])
}

model Trade {
  holderAddress String
  ownerAddress  String
  amount        BigInt
  ethCost       BigInt?
  protocolFee   BigInt?
  ownerFee      BigInt?
  block         BigInt
  chainId       Int
  hash          String  @unique
  timestamp     BigInt?

  //Whether or not the keyRelationship has been updated to reflect the trade
  //It will be false if the holder or the owner is not in the DB
  //This it to allow for the trade to be processed later if a user registers
  processed Boolean @default(false)

  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model KeyRelationship {
  holder   User   @relation(fields: [holderId], references: [id], name: "holder")
  holderId Int
  owner    User   @relation(fields: [ownerId], references: [id], name: "owner")
  ownerId  Int
  amount   BigInt

  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([holderId, ownerId])
}

model SystemSetting {
  key   String @unique
  value String

  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Quest {
  description String
  points      Int
  isActive    Boolean     @default(false)
  users       UserQuest[]

  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model UserQuest {
  user        User      @relation(fields: [userId], references: [id])
  userId      Int
  quest       Quest     @relation(fields: [questId], references: [id])
  questId     Int
  completedAt DateTime?

  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}
